<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java TSP</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .code-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin: 20px 0;
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .code-title {
            background-color: #2d3748;
            color: white;
            padding: 10px 20px;
            margin: 0 0 10px 0;
            border-radius: 5px;
            font-weight: bold;
            font-size: 16px;
        }
        
        .copy-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            margin: 0 0 10px 0;
            transition: background-color 0.3s;
        }
        
        .copy-button:hover {
            background-color: #45a049;
        }
        
        .copy-button.copied {
            background-color: #2196F3;
        }
        
        /* Plain text code styling - no syntax highlighting */
        .plain-code {
            font-family: 'Courier New', Consolas, Monaco, monospace;
            background-color: #f8f8f8;
            border: 1px solid #e1e1e1;
            border-radius: 5px;
            padding: 20px;
            margin: 0;
            overflow-x: auto;
            white-space: pre;
            font-size: 14px;
            line-height: 1.5;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>Java TSP</h1>
    
    <div class="code-container">
        <div class="code-title">Java Code</div>
        <button class="copy-button" onclick="copyCode()">ðŸ“‹ Copy Code</button>
        <pre class="plain-code" id="java-code">import java.util.*;

public class TravelingSalesman {
    private static int n; // number of cities
    private static int[][] dist; // distance matrix
    private static Scanner sc = new Scanner(System.in);
    
    public static void main(String[] args) {
        System.out.println("=== Traveling Salesman Problem Solver ===\n");
        
        // Get number of cities
        n = getNumberOfCities();
        
        // Initialize distance matrix
        dist = new int[n][n];
        
        // Get distance matrix from user
        getDistanceMatrix();
        
        // Get starting city
        int startCity = getStartingCity();
        
        // Solve TSP
        solveTSP(startCity);
    }
    
    private static int getNumberOfCities() {
        int cities;
        while (true) {
            try {
                System.out.print("Enter the number of cities: ");
                String input = sc.nextLine().trim();
                
                if (input.isEmpty()) {
                    System.out.println("Error: Please enter a valid number!");
                    continue;
                }
                
                cities = Integer.parseInt(input);
                
                if (cities &lt;= 0) {
                    System.out.println("Error: Number of cities must be positive!");
                    continue;
                }
                
                if (cities &lt; 2) {
                    System.out.println("Error: Need at least 2 cities for TSP!");
                    continue;
                }
                
                break;
            } catch (NumberFormatException e) {
                System.out.println("Error: Please enter a valid integer (no characters allowed)!");
            }
        }
        return cities;
    }
    
    private static void getDistanceMatrix() {
        System.out.println("\n*** IMPORTANT: Enter diagonal values as 0 (distance from a city to itself) ***");
        System.out.println("Enter the distance matrix (city to city distances):");
        System.out.println("Cities are numbered from 0 to " + (n-1));
        
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                while (true) {
                    try {
                        System.out.print("Distance from city " + i + " to city " + j + ": ");
                        String input = sc.nextLine().trim();
                        
                        if (input.isEmpty()) {
                            System.out.println("Error: Please enter a valid distance!");
                            continue;
                        }
                        
                        int distance = Integer.parseInt(input);
                        
                        if (distance &lt; 0) {
                            System.out.println("Error: Distance cannot be negative!");
                            continue;
                        }
                        
                        // Check diagonal values
                        if (i == j &amp;&amp; distance != 0) {
                            System.out.println("Warning: Diagonal value should be 0 (distance from city to itself)");
                            System.out.println("Setting distance from city " + i + " to city " + j + " as 0");
                            distance = 0;
                        }
                        
                        dist[i][j] = distance;
                        break;
                        
                    } catch (NumberFormatException e) {
                        System.out.println("Error: Please enter a valid integer (no characters allowed)!");
                    }
                }
            }
        }
        
        // Display the entered matrix
        System.out.println("\nDistance Matrix:");
        System.out.print("     ");
        for (int j = 0; j &lt; n; j++) {
            System.out.printf("%4d ", j);
        }
        System.out.println();
        
        for (int i = 0; i &lt; n; i++) {
            System.out.printf("%2d : ", i);
            for (int j = 0; j &lt; n; j++) {
                System.out.printf("%4d ", dist[i][j]);
            }
            System.out.println();
        }
    }
    
    private static int getStartingCity() {
        int startCity;
        while (true) {
            try {
                System.out.print("\nEnter the starting city (0 to " + (n-1) + "): ");
                String input = sc.nextLine().trim();
                
                if (input.isEmpty()) {
                    System.out.println("Error: Please enter a valid city number!");
                    continue;
                }
                
                startCity = Integer.parseInt(input);
                
                if (startCity &lt; 0 || startCity &gt;= n) {
                    System.out.println("Error: Starting city must be between 0 and " + (n-1) + "!");
                    continue;
                }
                
                break;
            } catch (NumberFormatException e) {
                System.out.println("Error: Please enter a valid integer (no characters allowed)!");
            }
        }
        return startCity;
    }
    
    private static void solveTSP(int startCity) {
        System.out.println("\n=== Solving TSP ===");
        System.out.println("Starting from city: " + startCity);
        
        // Create list of cities to visit (excluding start city)
        List&lt;Integer&gt; cities = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            if (i != startCity) {
                cities.add(i);
            }
        }
        
        int minCost = Integer.MAX_VALUE;
        List&lt;Integer&gt; bestPath = new ArrayList&lt;&gt;();
        
        // Generate all permutations
        List&lt;List&lt;Integer&gt;&gt; permutations = generatePermutations(cities);
        
        System.out.println("\nAnalyzing all possible routes...");
        
        for (List&lt;Integer&gt; perm : permutations) {
            // Calculate cost of this path
            int cost = 0;
            int currentCity = startCity;
            List&lt;Integer&gt; currentPath = new ArrayList&lt;&gt;();
            currentPath.add(startCity);
            
            // Visit all cities in this permutation
            for (int city : perm) {
                cost += dist[currentCity][city];
                currentPath.add(city);
                currentCity = city;
            }
            
            // Return to start city
            cost += dist[currentCity][startCity];
            currentPath.add(startCity);
            
            // Check if this is the best path so far
            if (cost &lt; minCost) {
                minCost = cost;
                bestPath = new ArrayList&lt;&gt;(currentPath);
            }
        }
        
        // Display results
        System.out.println("\n=== SOLUTION ===");
        System.out.println("Optimal path: " + bestPath);
        System.out.println("Minimum cost: " + minCost);
        
        // Display step-by-step path
        System.out.println("\nStep-by-step journey:");
        for (int i = 0; i &lt; bestPath.size() - 1; i++) {
            int from = bestPath.get(i);
            int to = bestPath.get(i + 1);
            System.out.println("City " + from + " -&gt; City " + to + " (distance: " + dist[from][to] + ")");
        }
    }
    
    private static List&lt;List&lt;Integer&gt;&gt; generatePermutations(List&lt;Integer&gt; cities) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        generatePermutationsHelper(cities, 0, result);
        return result;
    }
    
    private static void generatePermutationsHelper(List&lt;Integer&gt; cities, int start, List&lt;List&lt;Integer&gt;&gt; result) {
        if (start &gt;= cities.size()) {
            result.add(new ArrayList&lt;&gt;(cities));
            return;
        }
        
        for (int i = start; i &lt; cities.size(); i++) {
            Collections.swap(cities, start, i);
            generatePermutationsHelper(cities, start + 1, result);
            Collections.swap(cities, start, i); // backtrack
        }
    }
}
</pre>
    </div>


    <div class="code-container">
        <div class="code-title">Java Code</div>
        <!-- <button class="copy-button" onclick="copyCode()">ðŸ“‹ Copy Code</button> -->
        <pre class="plain-code" id="java-code">import java.util.*;

            import java.util.*;

public class MatrixChainDP {
    
    // Function to print optimal parenthesization
    static void printOptimalOrder(int i, int j, int[][] K, char[] name) {
        if (i == j) {
            System.out.print(name[i]); // single matrix
            return;
        }
        System.out.print("(");
        printOptimalOrder(i, K[i][j], K, name);
        printOptimalOrder(K[i][j] + 1, j, K, name);
        System.out.print(")");
    }
    
    // Function to validate matrix dimensions
    static boolean validateDimensions(int[] p, int n) {
        for (int i = 0; i <= n; i++) {
            if (p[i] <= 0) {
                System.out.println("Error: All dimensions must be positive!");
                return false;
            }
        }
        return true;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        try {
            // Input validation for number of matrices
            System.out.print("Enter number of matrices: ");
            int n = sc.nextInt();
            
            if (n <= 0) {
                System.out.println("Error: Number of matrices must be positive!");
                return;
            }
            
            if (n > 26) {
                System.out.println("Error: Cannot handle more than 26 matrices!");
                return;
            }
            
            // Input matrix dimensions
            int[] p = new int[n + 1];
            System.out.println("Enter matrix dimensions:");
            
            // Get first matrix dimensions
            System.out.print("Matrix A (Matrix 1) - Rows: ");
            p[0] = sc.nextInt();
            System.out.print("Matrix A (Matrix 1) - Columns: ");
            p[1] = sc.nextInt();
            
            // Get remaining matrices dimensions
            for (int i = 1; i < n; i++) {
                char matrixName = (char)('A' + i);
                System.out.print("Matrix " + matrixName + " (Matrix " + (i + 1) + ") - Rows: ");
                int rows = sc.nextInt();
                System.out.print("Matrix " + matrixName + " (Matrix " + (i + 1) + ") - Columns: ");
                p[i + 1] = sc.nextInt();
                
                // Validate matrix multiplication compatibility
                if (p[i] != rows) {
                    System.out.println("Error: Matrix " + (char)('A' + i - 1) + " columns (" + p[i] + 
                                     ") must equal Matrix " + matrixName + " rows (" + rows + ")!");
                    return;
                }
            }
            
            // Validate dimensions
            if (!validateDimensions(p, n)) {
                return;
            }
            
            // Display matrix dimensions for confirmation
            System.out.println("\nMatrix dimensions:");
            for (int i = 0; i < n; i++) {
                System.out.println("Matrix " + (char)('A' + i) + ": " + p[i] + " Ã— " + p[i + 1]);
            }
            
            // DP tables
            int[][] M = new int[n + 1][n + 1]; // cost table
            int[][] K = new int[n + 1][n + 1]; // split table
            
            // Initialize cost table (diagonal elements are 0)
            for (int i = 1; i <= n; i++) {
                M[i][i] = 0;
            }
            
            // L = chain length
            for (int L = 2; L <= n; L++) {
                for (int i = 1; i <= n - L + 1; i++) {
                    int j = i + L - 1;
                    M[i][j] = Integer.MAX_VALUE;
                    
                    for (int k = i; k < j; k++) {
                        // Check for potential overflow
                        long cost = (long)M[i][k] + (long)M[k + 1][j] + (long)p[i - 1] * p[k] * p[j];
                        
                        if (cost > Integer.MAX_VALUE) {
                            System.out.println("Warning: Cost overflow detected! Results may be inaccurate.");
                        }
                        
                        int q = (int)Math.min(cost, Integer.MAX_VALUE);
                        
                        if (q < M[i][j]) {
                            M[i][j] = q;
                            K[i][j] = k;
                        }
                    }
                }
            }
            
            // Print M table
            System.out.println("\nM (cost) table:");
            System.out.print("     ");
            for (int j = 1; j <= n; j++) {
                System.out.printf("%8d", j);
            }
            System.out.println();
            
            for (int i = 1; i <= n; i++) {
                System.out.printf("%3d: ", i);
                for (int j = 1; j <= n; j++) {
                    if (i > j) {
                        System.out.print("       -");
                    } else {
                        System.out.printf("%8d", M[i][j]);
                    }
                }
                System.out.println();
            }
            
            // Print K table
            System.out.println("\nK (split) table:");
            System.out.print("     ");
            for (int j = 1; j <= n; j++) {
                System.out.printf("%6d", j);
            }
            System.out.println();
            
            for (int i = 1; i <= n; i++) {
                System.out.printf("%3d: ", i);
                for (int j = 1; j <= n; j++) {
                    if (i >= j) {
                        System.out.print("     -");
                    } else {
                        System.out.printf("%6d", K[i][j]);
                    }
                }
                System.out.println();
            }
            
            // Results
            System.out.println("\n" + "=".repeat(50));
            System.out.println("RESULTS:");
            System.out.println("=".repeat(50));
            System.out.println("Minimum number of scalar multiplications: " + M[1][n]);
            
            // Optimal parenthesization
            char[] name = new char[n + 1]; // Only allocate what we need
            for (int i = 0; i <= n; i++) {
                name[i] = (char)('A' + i - 1); // A, B, C, etc. (starting from index 1)
            }
            
            System.out.print("Optimal parenthesization: ");
            if (n == 1) {
                System.out.println("A");
            } else {
                printOptimalOrder(1, n, K, name);
                System.out.println();
            }
            
        } catch (InputMismatchException e) {
            System.out.println("Error: Please enter valid integers only!");
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            sc.close();
        }
    }
}
    </pre>
    </div>
    
    <script>
        function copyCode() {
            const codeElement = document.getElementById('java-code');
            const button = document.querySelector('.copy-button');
            
            // Get the plain text content without HTML formatting
            const codeText = codeElement.textContent || codeElement.innerText;
            
            // Create a temporary textarea to copy the text
            const textarea = document.createElement('textarea');
            textarea.value = codeText;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            
            // Update button to show success
            const originalText = button.innerHTML;
            button.innerHTML = 'âœ… Copied!';
            button.classList.add('copied');
            
            // Reset button after 2 seconds
            setTimeout(() => {
                button.innerHTML = originalText;
                button.classList.remove('copied');
            }, 2000);
        }
        
        // Alternative modern approach for copying (fallback)
        async function copyCodeModern() {
            const codeElement = document.getElementById('java-code');
            const codeText = codeElement.textContent || codeElement.innerText;
            
            try {
                await navigator.clipboard.writeText(codeText);
                console.log('Code copied successfully');
            } catch (err) {
                console.log('Fallback to old copy method');
                copyCode();
            }
        }
    </script>
</body>
</html>